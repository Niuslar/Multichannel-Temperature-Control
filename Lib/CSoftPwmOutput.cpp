/*
 * CSoftPwmOutput.cpp
 *
 *  Created on: 20 Feb 2022
 *      Author: salavat.magazov
 */

#include "CSoftPwmOutput.h"

TIM_HandleTypeDef *CSoftPwmOutput::sp_timer = nullptr;
uint32_t CSoftPwmOutput::s_period = 100;
uint32_t CSoftPwmOutput::s_counter = 0;
CSoftPwmOutput *CSoftPwmOutput::sp_first_instance = nullptr;

// TODO: refactor this class to inherit from GPIO rather than own it.
/**
 * @brief Construct an instance of soft PWM timer based on GPIO.
 *
 * @param p_gpio pointer to GPIO to be controlled by soft PWM.
 */
CSoftPwmOutput::CSoftPwmOutput(CGpioWrapper *p_gpio)
    : mp_next_instance(nullptr),
      mp_gpio(p_gpio),
      m_duty_cycle(0)
{
    if (sp_first_instance == nullptr)
    {
        sp_first_instance = this;
    }
    else
    {
        CSoftPwmOutput *p_previous_instance = getLastInstance();
        p_previous_instance->mp_next_instance = this;
    }
    mp_next_instance = nullptr;
    p_gpio->set(false);
}

/**
 * @brief Set duty cycle of the PWM output.
 *
 * @param duty_cycle_percent Percentage value of duty cycle.
 */
void CSoftPwmOutput::setDutyCycle(float duty_cycle_percent)
{
    duty_cycle_percent *= s_period + 1;
    m_duty_cycle = duty_cycle_percent / 100;
    if (m_duty_cycle > s_period)
    {
        m_duty_cycle = s_period;
    }
}

/**
 * @brief Get current duty cycle.
 *
 * @return Current duty cycle generated by the class.
 */
float CSoftPwmOutput::getDutyCycle() const
{
    return (m_duty_cycle / s_period);
}

/**
 * @brief Initialise the class.
 * @note This init only needs to be called once for all instances.
 * For operation with timer, it is assumed that timer has been fully setup.
 * For operation without a timer, user needs to ensure repeated calls to tick()
 * method to keep the PWM operational.
 *
 * @param period Period of the PWM.
 * @param p_timer Pointer to hardware timer control structure.
 */
void CSoftPwmOutput::init(uint32_t period, TIM_HandleTypeDef *p_timer)
{
    if (p_timer != nullptr)
    {
        HAL_TIM_RegisterCallback(sp_timer,
                                 HAL_TIM_PERIOD_ELAPSED_CB_ID,
                                 softPwmTimerTick);
    }
    sp_timer = p_timer;
    s_period = period;
}

/**
 * @brief Method that looks after the soft PWM.
 * @note It gets called automatically by timer callback if timer has been
 * configured. If timer has not been configured, then user needs to ensure
 * regular calls to this method.
 */
void CSoftPwmOutput::tick()
{
    if (++s_counter >= s_period)
    {
        s_counter = 0;
    }
    CSoftPwmOutput *p_instance = sp_first_instance;
    while (p_instance != nullptr)
    {
        bool b_output = false;
        if (s_counter < p_instance->m_duty_cycle)
        {
            b_output = true;
        }
        p_instance->mp_gpio->set(b_output);
        p_instance = p_instance->mp_next_instance;
    }
}

/**
 * @brief Get pointer to timer that runs the soft PWM.
 *
 * @return Pointer to timer control structure.
 */
TIM_HandleTypeDef *const CSoftPwmOutput::getTimer()
{
    return sp_timer;
};

/**
 * @brief Get last fully configured instance of soft PWM class.
 *
 * @return Pointer to last configured instance.
 */
CSoftPwmOutput *CSoftPwmOutput::getLastInstance()
{
    CSoftPwmOutput *p_instance = sp_first_instance;
    while (p_instance->mp_next_instance != nullptr)
    {
        p_instance = p_instance->mp_next_instance;
    }
    return p_instance;
}
